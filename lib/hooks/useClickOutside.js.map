{"version":3,"file":"useClickOutside.js","sourceRoot":"","sources":["../../src/hooks/useClickOutside.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAE1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CG;AAEH,MAAM,UAAU,eAAe,CAAC,cAA0B;IACxD,MAAM,eAAe,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAEtC,SAAS,CAAC,GAAG,EAAE;QACb,SAAS,mBAAmB;YAC1B,IAAI,eAAe,CAAC,OAAO,EAAE;gBAC3B,eAAe,CAAC,OAAO,GAAG,KAAK,CAAC;aACjC;iBAAM;gBACL,cAAc,EAAE,CAAC;aAClB;QACH,CAAC;QAED,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;QACxD,OAAO,GAAG,EAAE;YACV,QAAQ,CAAC,mBAAmB,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;QAC7D,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,OAAO,SAAS,cAAc;QAC5B,eAAe,CAAC,OAAO,GAAG,IAAI,CAAC;IACjC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div react-data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div react-data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the document\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the document click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the document is set using document.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\nexport function useClickOutside(onClickOutside: () => void) {\n  const isClickedInside = useRef(false);\n\n  useEffect(() => {\n    function handleDocumentClick() {\n      if (isClickedInside.current) {\n        isClickedInside.current = false;\n      } else {\n        onClickOutside();\n      }\n    }\n\n    document.addEventListener('click', handleDocumentClick);\n    return () => {\n      document.removeEventListener('click', handleDocumentClick);\n    };\n  });\n\n  return function onClickCapture() {\n    isClickedInside.current = true;\n  };\n}\n"]}